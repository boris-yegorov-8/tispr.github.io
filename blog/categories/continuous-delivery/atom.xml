<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Continuous Delivery | tispr Engineering]]></title>
  <link href="http://engineering.tispr.com/blog/categories/continuous-delivery/atom.xml" rel="self"/>
  <link href="http://engineering.tispr.com/"/>
  <updated>2017-01-23T23:23:06+00:00</updated>
  <id>http://engineering.tispr.com/</id>
  <author>
    <name><![CDATA[BuddyHopp, Inc.]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Running Docker in a GoCD Agent That Runs in a Docker]]></title>
    <link href="http://engineering.tispr.com/blog/2015/08/19/running-docker-in-gocd-agent-that-runs-in-docker/"/>
    <updated>2015-08-19T02:08:27+00:00</updated>
    <id>http://engineering.tispr.com/blog/2015/08/19/running-docker-in-gocd-agent-that-runs-in-docker</id>
    <content type="html"><![CDATA[<p>Setting up Continuous Delivery may be challenging. However, it is definitely worth the time and resource investment,
if you want to release often, maintain a high quality of released products and have full control over the complete process.
<a href="http://www.go.cd/">GoCD</a> is built on a pipelines concept described in <a href="http://martinfowler.com/books/continuousDelivery.html">Continuous Delivery book</a>.
<a href="https://www.docker.com/">Docker</a> greatly fits into the concept, because it solves the problem of packaging applications with all required dependencies and configurations into a standardized container unit.
A common build pipeline will use a Dockerfile as an input, create an image and publish it to a Docker registry.
A common deploy pipeline will use a Docker registry image as an input and deploy it to a proper environment when it is updated.</p>

<p>GoCD in its basic setup is distributed and has a Server and one or more Agents, which are running actual Jobs and Tasks.
The Server can be customized by adding new plugins, or by setting up a backed-up pipeline configuration.
The Agents may have different resources to run different types of jobs, i.e. separate Agents to build java and node.js projects.
Same as for any other software deliverable, packaging GoCD Server and Agents into Docker containers simplifies their deployment and maintainability.
One of the challenges in this setup is running your existing Docker pipelines in an Agent, which is running in a Docker container.</p>

<p>So, in brief, you may find this article interesting, if you:</p>

<ul>
<li>use GoCD;</li>
<li>use Docker;</li>
<li>use GoCD to build Docker images;</li>
<li>run GoCD agents in a Docker.</li>
</ul>


<p>The most important part of this setup is a <a href="https://hub.docker.com/r/jpetazzo/dind/">Docker-in-Docker</a>, which we use as a base image:
<code>
FROM jpetazzo/dind
</code></p>

<p>To run a GoCD agent in a Docker, we need to run several processes in one container. For this let&rsquo;s use <a href="http://docs.docker.com/articles/using_supervisord/">supervisor</a>:
<code>
RUN apt-get -y install supervisor
ADD supervisord.conf /etc/supervisor/conf.d/supervisord.conf
CMD ["/usr/bin/supervisord"]
</code></p>

<p>The configuration file for the supervisor will contain a section per each process, including the supervisor itself:</p>

<pre><code>[supervisord]
nodaemon=true

[program:docker]
priority=10
command=wrapdocker

[program:gocdagent]
priority=20
command=/bin/bash -c "/etc/init.d/go-agent start"
</code></pre>

<p>Some additional tweaks may be required to run your GoCD agent properly. One of them is setting <code>GO_SERVER</code> in your agent configuration. Let&rsquo;s assume that it is available as an environment variable with the same name:
<code>
echo export GO_SERVER=$GO_SERVER &gt;&gt; /etc/default/go-agent
</code></p>

<p>Another update will allow to run <code>sudo docker</code> without an interactive password prompt:
<code>
echo go ALL=NOPASSWD: /usr/bin/docker &gt;&gt; /etc/sudoers
</code></p>

<p>And the complete GoCD command will look like this:
<code>
command=/bin/bash -c "echo export GO_SERVER=$GO_SERVER &gt;&gt; /etc/default/go-agent &amp;&amp; echo go ALL=NOPASSWD: /usr/bin/docker &gt;&gt; /etc/sudoers &amp;&amp; /etc/init.d/go-agent start"
</code></p>

<p>You can check the complete <a href="https://github.com/tispr/docker-gocd/tree/master/gocd-agent-dind/">Dockerfile</a> and start playing
with existing image by pulling <a href="https://hub.docker.com/r/tispr/gocd-agent-dind/">tispr/gocd-agent-dind</a>:
<code>
docker pull tispr/gocd-agent-dind
</code></p>

<p>Now nothing stops you from setting up a GoCD pipeline to manage dockerized GoCD Server and GoCD Agents.</p>

<h2>References</h2>

<ul>
<li>Docker in Docker: <a href="https://github.com/jpetazzo/dind/">https://github.com/jpetazzo/dind/</a></li>
<li>Go Continuous Delivery: <a href="http://www.go.cd/">http://www.go.cd/</a></li>
<li>Jenkins DIND: <a href="https://github.com/killercentury/docker-jenkins-dind">https://github.com/killercentury/docker-jenkins-dind</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Display Build Number and Version on an iOS App Icon]]></title>
    <link href="http://engineering.tispr.com/blog/2015/08/02/how-to-display-build-number-and-version-on-an-ios-app-icon/"/>
    <updated>2015-08-02T21:30:19+00:00</updated>
    <id>http://engineering.tispr.com/blog/2015/08/02/how-to-display-build-number-and-version-on-an-ios-app-icon</id>
    <content type="html"><![CDATA[<p>How often do you face the situation where your colleagues, QA, business or marketing report issues in test builds, but they forget to mention a build number or application version? And when they ask you about it, you spend a lot of time explaining the build number and application version, and where it can be found? When you have one to two builds per month the issue is not very big, but when you have a lot of different builds per week, it becomes cumbersome.</p>

<p>-For instance at <a href="http://tispr.com">tispr</a> we build on each commit and every week for internal testing, and weekly demo&rsquo;s for business &amp; marketing departments.</p>

<p>Let&rsquo;s solve this issue, by creating a build number and app version with maximum visibility for users!</p>

<p>Our solution: On the application icon.
You must be thinking: A new icon for each new build?! Our answer is yes, why not.</p>

<p>Let&rsquo;s look at the how:</p>

<p><img class="left ({{ root_url }}" src="/images/2015-08-02-how-to-stop-explain-where-application-version-can-be-found/app_icon.png" width="100" height="100" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" >
<strong>Develop</strong> - it is type/name of build (if you have a different type of builds, for instance: Develop build, Business build, etc);
<strong>1.0.1</strong> - application version;
<strong>1023</strong> - build number</p>

<p><br/>
<em>Let&rsquo;s code:</em></p>

<p>Add new &ldquo;Run Script&rdquo; in Xcode in &ldquo;Build Phase&rdquo;
<img src="%20/images/2015-08-02-how-to-stop-explain-where-application-version-can-be-found/build_phase_1.png" alt="application icon with overlay" />
<img src="%20/images/2015-08-02-how-to-stop-explain-where-application-version-can-be-found/build_phase_2.png" alt="application icon with overlay" /></p>

<p>Get build number and application version from info plist in script
<code>
version=`/usr/libexec/PlistBuddy -c "Print CFBundleShortVersionString" "${INFOPLIST_FILE}"`
build=`/usr/libexec/PlistBuddy -c "Print CFBundleVersion" "${INFOPLIST_FILE}"`
</code></p>

<p>Let&rsquo;s imagine that we have a function with the name &ldquo;addOverlayInfo&rdquo; which has two parameters (name of incoming icon, name of icon that will be generated)
<code>
function addOverlayInfo() {
    income_icon_name=$1
    outcome_icon_name=$2
</code></p>

<p>The result is something like this:
<code>
addOverlayInfo "iPhone-60@2x.png" "AppIcon60x60@2x.png"
addOverlayInfo "iPhone-60@3x.png" "AppIcon60x60@3x.png"
</code></p>

<p>where <code>iPhone-60@2x.png</code>, <code>iPhone-60@3x.png</code> - the names of the current application icons
While the application builds the Xcode, the icons with the names <code>AppIcon60x60@2x.png</code>, <code>AppIcon60x60@3x.png</code> will be generated, if you use Images.xcassets.
So, these names are used as second parameters in our calls.</p>

<p>Let&rsquo;s find the icon path by name of the icon:
<code>
income_icon_path=`find ${SRCROOT} -name $income_icon_name`
</code></p>

<p>Create a path to save the generated icon:
<code>
outcome_icon_path="${CONFIGURATION_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/${outcome_icon_name}"
</code></p>

<p>And now the most important moment: Generating icons with an overlay, including the build number and application version.</p>

<p>Following a quick search on the internet we found that we will need these packages(imagemagick and ghostscript). Let&rsquo;s install them:
<code>
brew install imagemagick
brew install ghostscript
</code>
To find the width of the incoming icon:
<code>
width=`identify -format %w ${income_icon_path}`
</code></p>

<p>To generate the new icon with all the important information:
<code>
convert -background '#0008' -fill white -gravity center -size ${width}x60 -pointsize 20\
caption:"$TYPE_OF_BUILD $version($build)" ${income_icon_path} +swap -gravity south -composite ${outcome_icon_path}
</code></p>

<p><code>$TYPE_OF_BUILD</code> - The name of our build.
To complete the process you might want to consider automating it by making it part of your Continuous Delivery process.</p>

<p><em>Mission completed</em></p>

<p>You can find the full script here: <a href="https://gist.github.com/Pitsko/993d81ac76e8d04ca1bc">Code</a></p>

<p>This article was inspired by these posts: <br/>
<a href="http://habrahabr.ru/post/262667/">http://habrahabr.ru/post/262667/</a> <br/>
<a href="http://merowing.info/2013/03/overlaying-application-version-on-top-of-your-icon">http://merowing.info/2013/03/overlaying-application-version-on-top-of-your-icon</a></p>
]]></content>
  </entry>
  
</feed>
